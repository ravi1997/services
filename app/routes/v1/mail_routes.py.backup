from flask import Blueprint, request, current_app, g
from app.utils.response import success, error
import uuid
from app.utils.decorators import require_bearer_and_log
from app.tasks.email_queue import add_to_queue_task, process_health_check_task, get_queue_status
import threading
import time
import logging
from typing import Dict, Any


mail_bp = Blueprint('mail', __name__)


def _get_ip_range():
    """Get client IP, checking for reverse proxy headers"""
    # Check for common reverse proxy headers
    forwarded_for = request.headers.get('X-Forwarded-For')
    if forwarded_for:
        # X-Forwarded-For can contain multiple IPs, take the first one
        ip = forwarded_for.split(',')[0].strip()
        return ip
    real_ip = request.headers.get('X-Real-IP')
    if real_ip:
        return real_ip
    return request.remote_addr


def _check_ip_allowed():
    """Check if the client IP is in the allowed range"""
    client_ip = _get_ip_range()
    if client_ip.startswith('192.168.14.'):
        return True
    return False


@mail_bp.route('/health', methods=['GET'])
def mail_health():
    # Check IP range for access
    if not _check_ip_allowed():
        logging.getLogger('access').error(f"Health check access denied from IP: {_get_ip_range()}")
        return error("Access denied", "ACCESS_DENIED", 403)
    
    # Log access
    access_logger = logging.getLogger('access')
    access_logger.info(f"Health check request from IP: {_get_ip_range()}")
    
    try:
        # Add health check task to the front of the queue (high priority)
        result = add_to_queue_task.delay('process_health_check', is_high_priority=True)
        
        # Get queue status for the response
        queue_info = get_queue_status()
        
        # Return the health check result with queue information
        if result.ready():
            health_result = result.get(timeout=10)  # Wait up to 10 seconds
            health_result['queue_info'] = queue_info
            return success("Email service health check completed", health_result)
        else:
            # Task is still in queue, return pending status
            return success("Health check task queued", {
                "status": "pending", 
                "task_id": result.id,
                "queue_info": queue_info
            })
    except Exception as e:
        error_logger = logging.getLogger('error')
        error_logger.error(f"Health check error: {str(e)}")
        return error("Email service health check failed", "HEALTH_CHECK_ERROR", 503)


@mail_bp.route('/send', methods=['POST'])
@require_bearer_and_log
def mail_send():
    # Check IP range
    if not _check_ip_allowed():
        logging.getLogger('access').error(f"Single send access denied from IP: {_get_ip_range()}")
        return error("Access denied", "ACCESS_DENIED", 403)
    
    payload = request.get_json(silent=True) or {}
    to = payload.get('to')
    subject = payload.get('subject')
    body = payload.get('body')
    correlation_id = payload.get('correlation_id', str(uuid.uuid4()))
    
    if not to or not subject or not body:
        return error("Missing required fields: to, subject, or body", "EMAIL_SERVICE_ERROR", 400)
    
    # Validate email format
    import re
    email_pattern = re.compile(r'^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}')
    if not email_pattern.match(str(to)):
        return error("Invalid email address format", "INVALID_EMAIL", 400)
    
    try:
        # Add email task to queue
        result = add_to_queue_task.delay(
            'process_single_email', 
            is_high_priority=False, 
            to, 
            subject, 
            body, 
            correlation_id
        )
        
        # If result is immediate (not queued), return it
        if result.ready() and result.successful():
            immediate_result = result.get()
            if immediate_result.get('status') == 'sent':
                return success("Email sent successfully", {
                    "message_id": immediate_result.get('message_id'),
                    "to": immediate_result.get('to_email'),
                    "status": immediate_result.get('status'),
                    "correlation_id": correlation_id
                })
        
        # Otherwise return queued status
        if isinstance(result, dict) and 'status' in result and result['status'] == 'queued':
            return success("Email send request queued", {
                "status": "queued", 
                "correlation_id": correlation_id,
                "queue_length": result.get('queue_length', 0)
            })
        else:
            return success("Email send request queued", {
                "status": "queued", 
                "correlation_id": correlation_id
            })
    except Exception as e:
        error_logger = logging.getLogger('error')
        error_logger.error(f"Error queuing email for {to}: {str(e)}")
        return error("Failed to queue email for sending", "EMAIL_SERVICE_ERROR", 500)


@mail_bp.route('/bulk_send', methods=['POST'])
@require_bearer_and_log
def mail_bulk_send():
    # Check IP range
    if not _check_ip_allowed():
        logging.getLogger('access').error(f"Bulk send access denied from IP: {_get_ip_range()}")
        return error("Access denied", "ACCESS_DENIED", 403)
    
    payload = request.get_json(silent=True) or {}
    recipients = payload.get('to')
    subject = payload.get('subject')
    body = payload.get('body')
    correlation_id = payload.get('correlation_id', str(uuid.uuid4()))
    
    if not isinstance(recipients, list) or not recipients or not subject or not body:
        return error("Invalid payload for bulk email: need 'to' (list), 'subject', and 'body'", "EMAIL_SERVICE_ERROR", 400)
    
    # Limit to 200 recipients at a time
    if len(recipients) > 200:
        return error("Too many recipients. Maximum 200 per request", "TOO_MANY_RECIPIENTS", 400)
    
    # Validate all email addresses
    import re
    email_pattern = re.compile(r'^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}

)
    invalid_emails = [email for email in recipients if not email_pattern.match(str(email))]
    if invalid_emails:
        return error(f"Invalid email addresses: {invalid_emails}", "INVALID_EMAIL", 400)
    
    try:
        # Add each email to the queue
        queued_count = 0
        failed_count = 0
        results = []
        
        for recipient in recipients:
            try:
                result = add_to_queue_task.delay(
                    'process_single_email', 
                    is_high_priority=False, 
                    recipient, 
                    subject, 
                    body, 
                    correlation_id
                )
                results.append(result)
                queued_count += 1
            except Exception as e:
                error_logger = logging.getLogger('error')
                error_logger.error(f"Error queuing email for {recipient}: {str(e)}")
                failed_count += 1
        
        if failed_count == len(recipients):
            return error("Failed to queue all emails", "EMAIL_SERVICE_ERROR", 500)
        
        return success("Bulk email requests queued", {
            "queued_count": queued_count,
            "failed_count": failed_count,
            "correlation_id": correlation_id,
            "total_recipients": len(recipients)
        })
    except Exception as e:
        error_logger = logging.getLogger('error')
        error_logger.error(f"Error queuing bulk emails: {str(e)}")
        return error("Failed to queue bulk emails", "EMAIL_SERVICE_ERROR", 500)

